只需要写参数结构体或响应结构体
遇到固定值的参数就建一个枚举
固定的数字参数例如：扫码的状态码
```rust
pub enum LoginQRStatue {
    NoScan,
    TimeoutOrFailure,
    Scanned,
    Success,
}
```
可以直接这样写
```rust
use make_serde::{MakeSerde, SummonFrom};
#[derive(Debug, Clone, Copy, MakeSerde, SummonFrom)]
#[make_serde(try,type=u32)]
#[summon(type=u32)]
pub enum LoginQRStatue {
    NoScan,
    TimeoutOrFailure,
    Scanned,
    Success,
}
```
这样就会自动生成 `impl TryFrom<u32> for LoginQRStatue` 和 `impl From<LoginQRStatue> for u32` 两个实现 和 Serialize 和 Deserialize 两个 trait 实现
如果值大体固定而有部分不固定的值可以使用 `#[other]` 标记，例如：
```rust
#[derive(Debug, Clone, Copy, MakeSerde, SummonFrom)]
#[make_serde(try,type=u32)]
#[summon(type=u32)]
pub enum LoginQRStatue {
    NoScan,
    TimeoutOrFailure,
    Scanned,
    Success,
    #[other]
    Other(u32),
}
```
遇到字符串类型则不能使用 `MakeSerde` 和 `SummonFrom` 宏，需要手动实现 `From` 和 `Into`  trait
但是可以使用 `crate::make_serde!` 宏来手动实现 `Serialize` 和 `Deserialize`  trait
例如视频平台参数：
```rust
pub enum VideoPlatform {
    PC,
    Html5,
}
```
可以手动实现 `From` 和 `Into`  trait
```rust
impl From<VideoPlatform> for String {
    fn from(value: VideoPlatform) -> Self {
        match value {
            VideoPlatform::PC => "pc".to_string(),
            VideoPlatform::Html5 => "html5".to_string(),
        }
    }
}
impl TryFrom<String> for VideoPlatform {
    type Error = String;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        match value.as_str() {
            "pc" => Ok(VideoPlatform::PC),
            "html5" => Ok(VideoPlatform::Html5),
            _ => Err(format!("invalid video platform: {}", value)),
        }
    }
}
```
然后再使用 `crate::make_serde!` 宏来手动实现 `Serialize` 和 `Deserialize`  trait
```rust
make_serde! {
    pub mod serde_video_platform(VideoPlatform) {
        (deserializer) => {
            String::deserialize(deserializer)?.try_into().map_err(serde::de::Error::custom)
        },
        (platform, serializer) => {
           serializer.serialize_str(platform.into())
        },
    }
}
```
API的必填参数要写在函数的参数中，可选参数要写在结构体中
响应参数只需要写data中的字段，不需要写code和message字段
所有的REST请求返回值的反序列化都要包裹在 `APIResponse<T>` 结构体中，其中 `T` 是响应数据的结构体
解包请使用 `APIResponse<T>::into_result` 方法
`T` 是响应数据的结构体，例如：
```rust
pub struct LoginQRResponse {
    pub qr_code: String,
    pub qr_code_key: String,
    pub status: LoginQRStatue,
}
```
其中每个字段都要有详细的说明文档，例如：
```rust
/// 二维码图片
pub qr_code: String,
/// 二维码key
pub qr_code_key: String,
/// 扫码状态
pub status: LoginQRStatue,
```
结构体也都要实现 `Debug`、`Deserialize`、`Serialize` 三个 trait，按需实现 `Clone` trait
